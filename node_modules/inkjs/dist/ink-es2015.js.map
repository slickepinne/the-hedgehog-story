{"version":3,"file":"ink-es2015.js","sources":["../src/engine/Path.ts","../src/engine/Debug.ts","../src/engine/Value.ts","../src/engine/PushPop.ts","../src/engine/TypeAssertion.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/SearchResult.ts","../src/engine/Container.ts","../src/engine/Glue.ts","../src/engine/ControlCommand.ts","../src/engine/Pointer.ts","../src/engine/Divert.ts","../src/engine/ChoicePoint.ts","../src/engine/VariableReference.ts","../src/engine/VariableAssignment.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinition.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts","../src/engine/Story.ts"],"sourcesContent":["export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push.apply(p._components, this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    // Implicitly convert bools into ints\n    if (typeof val === \"boolean\") {\n      let b = !!val;\n      val = b ? 1 : 0;\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string }\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            comps.unshift(new Path.Component(namedChild.name));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      if (otherList._originNames) {\n        this._originNames = otherList._originNames.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1]; /* as Story */\n      this.SetInitialOriginName(singleOriginListName);\n\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public AddItem(itemOrItemName: InkListItem | string | null) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else {\n      let itemName = itemOrItemName as string | null;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null)\n        throw new Error(\n          \"Could not add the item \" +\n            itemName +\n            \" to this list because it isn't known to any list definitions previously associated with this list.\"\n        );\n\n      let item = new InkListItem(foundListDef.name, itemName);\n      let itemVal = foundListDef.ValueForItem(item);\n      this.Add(item, itemVal);\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n  public Contains(otherList: InkList) {\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string = \"\";\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    this.namedContent.set(namedContentObj.name, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null = currentContainer.ContentWithPathComponent(\n        comp\n      );\n\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = asOrNull(foundObj, Container);\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content[index] = contentObj;\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content = this.content.concat(otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public toString() {\n    return this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart,\n    EvalOutput,\n    EvalEnd,\n    Duplicate,\n    PopEvaluatedValue,\n    PopFunction,\n    PopTunnel,\n    BeginString,\n    EndString,\n    NoOp,\n    ChoiceCount,\n    Turns,\n    TurnsSince,\n    Random,\n    SeedRandom,\n    VisitIndex,\n    SequenceShuffleIndex,\n    StartThread,\n    Done,\n    End,\n    ListFromInt,\n    ListRange,\n    ListRandom,\n    ReadCount,\n\n    TOTAL_VALUES,\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {}\n","import { Value, ValueType, IntValue, ListValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          'Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T>(parametersOfSingleType: Array<Value<T>>) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0);\n      return new IntValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));\n      this.AddIntBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));\n      this.AddIntBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => (x >= y ? 1 : 0));\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));\n      this.AddIntUnaryOp(this.Not, (x) => (x == 0 ? 1 : 0));\n\n      this.AddIntBinaryOp(this.And, (x, y) => (x != 0 && y != 0 ? 1 : 0));\n      this.AddIntBinaryOp(this.Or, (x, y) => (x != 0 || y != 0 ? 1 : 0));\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));\n      this.AddFloatBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));\n      this.AddFloatBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x >= y ? 1 : 0\n      );\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));\n      this.AddFloatUnaryOp(this.Not, (x) => (x == 0.0 ? 1 : 0));\n\n      this.AddFloatBinaryOp(this.And, (x, y) => (x != 0.0 && y != 0.0 ? 1 : 0));\n      this.AddFloatBinaryOp(this.Or, (x, y) => (x != 0.0 || y != 0.0 ? 1 : 0));\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => (x === y ? 1 : 0));\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => (!(x === y) ? 1 : 0));\n      this.AddStringBinaryOp(this.Has, (x, y) => (x.includes(y) ? 1 : 0));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => (x.includes(y) ? 0 : 1));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => (x.Contains(y) ? 1 : 0));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => (x.Contains(y) ? 0 : 1));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => (x.Equals(y) ? 1 : 0));\n      this.AddListBinaryOp(this.Greater, (x, y) => (x.GreaterThan(y) ? 1 : 0));\n      this.AddListBinaryOp(this.Less, (x, y) => (x.LessThan(y) ? 1 : 0));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y) ? 1 : 0\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y) ? 1 : 0\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => (!x.Equals(y) ? 1 : 0));\n\n      this.AddListBinaryOp(this.And, (x, y) =>\n        x.Count > 0 && y.Count > 0 ? 1 : 0\n      );\n      this.AddListBinaryOp(this.Or, (x, y) =>\n        x.Count > 0 || y.Count > 0 ? 1 : 0\n      );\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => (d1.Equals(d2) ? 1 : 0);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) =>\n        d1.Equals(d2) ? 0 : 1;\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<\n    ValueType,\n    BinaryOp<any> | UnaryOp<any>\n  > | null = null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { InkObject } from \"./Object\";\n\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n}\n","import { InkList, InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n  public TryGetValueForItem(\n    item: InkListItem,\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asNumberOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (typeof token === \"number\" && !isNaN(token)) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" + JSON.stringify(token)\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    return choice;\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot;\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new StoryException(\n        \"Could not find temporary variable to set: \" + name\n      );\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container === null) {\n                return throwNullException(\"pointer.container\");\n              }\n              storyContext.Warning(\n                \"When loading state, exact internal story location couldn't be found: '\" +\n                  currentContainerPathStr +\n                  \"', so it was approximated to '\" +\n                  pointer.container.path.toString() +\n                  \"' to recover. Has the story changed since this save data was created?\"\n              );\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables = JsonSerialisation.JObjectToDictionaryRuntimeObjs(\n              temps\n            );\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class VariablesState {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  get batchObservingVariableChanges() {\n    return this._batchObservingVariableChanges;\n  }\n  set batchObservingVariableChanges(value: boolean) {\n    this._batchObservingVariableChanges = value;\n    if (value) {\n      this._changedVariablesForBatchObs = new Set();\n    } else {\n      if (this._changedVariablesForBatchObs != null) {\n        for (let variableName of this._changedVariablesForBatchObs) {\n          let currentValue = this._globalVariables.get(variableName);\n          if (!currentValue) {\n            throwNullException(\"currentValue\");\n          } else {\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n\n        this._changedVariablesForBatchObs = null;\n      }\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  private _batchObservingVariableChanges: boolean = false;\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string, value: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new StoryException(\"Cannot pass null to VariableState\");\n        } else {\n          throw new StoryException(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // thr proxy object is not available in this context. we should warn the\n      // dev but writting to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject = JsonSerialisation.JTokenToRuntimeObject(\n          loadedToken\n        );\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer = this.ResolveVariablePointer(\n          varPointer\n        );\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this.batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 16807) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public ToString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection() {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StoryException } from \"./StoryException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class StoryState {\n  public readonly kInkSaveStateVersion = 8;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.ToString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  public callStack: CallStack;\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get visitCounts() {\n    return this._visitCounts;\n  }\n\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      for (let outputObj of this._outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (textContent !== null) {\n          sb.Append(textContent.value);\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n\n      for (let outputObj of this._outputStream) {\n        // var tag = outputObj as Tag;\n        let tag = asOrNull(outputObj, Tag);\n        if (tag !== null) {\n          this._currentTags.push(tag.text);\n        }\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._outputStream = [];\n    this.OutputStreamDirty();\n\n    this._evaluationStack = [];\n\n    this.callStack = new CallStack(story);\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this._currentChoices = [];\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public CopyAndStartPatching() {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy.outputStream.push.apply(copy.outputStream, this._outputStream);\n    copy.OutputStreamDirty();\n\n    copy._currentChoices.push.apply(copy._currentChoices, this._currentChoices);\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push.apply(\n        copy._currentErrors,\n        this.currentErrors || []\n      );\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push.apply(\n        copy._currentWarnings,\n        this.currentWarnings || []\n      );\n    }\n\n    copy.callStack = new CallStack(this.callStack);\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push.apply(copy.evaluationStack, this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    let hasChoiceThreads = false;\n    for (let c of this._currentChoices) {\n      if (c.threadAtGeneration === null) {\n        return throwNullException(\"c.threadAtGeneration\");\n      }\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    // In the following two calls, `WriteJson` is called inside an arrow\n    // function to make sure `this` is correctly bound and passed down\n    // the call hierarchy.\n\n    writer.WriteProperty(\"callstackThreads\", (w) =>\n      this.callStack.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this._outputStream)\n    );\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this._currentChoices) JsonSerialisation.WriteChoice(w, c);\n      w.WriteArrayEnd();\n    });\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new StoryException(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new StoryException(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    this.callStack.SetJsonToken(jObject[\"callstackThreads\"], this.story);\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    this._outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"outputStream\"]\n    );\n    this.OutputStreamDirty();\n\n    // currentChoices = Json.JArrayToRuntimeObjList<Choice>((JArray)jObject [\"currentChoices\"]);\n    this._currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"currentChoices\"]\n    ) as Choice[];\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n\n    // var jChoiceThreads = jObject[\"choiceThreads\"] as JObject;\n    let jChoiceThreads = jObject[\"choiceThreads\"] as Record<string, any>;\n\n    for (let c of this._currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        c.originalThreadIndex\n      );\n      if (foundActiveThread != null) {\n        c.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[c.originalThreadIndex.toString()];\n        c.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          this.story\n        );\n      }\n    }\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this._outputStream.length = 0;\n    if (objs !== null) this._outputStream.push.apply(this._outputStream, objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; ++i) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = 0; i < str.length; ++i) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(\n        innerStrStart,\n        innerStrEnd - innerStrStart\n      );\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(tailLastNewlineIdx + 1, numSpaces)\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this._outputStream.length - 1; i >= 0; i--) {\n        let o = this._outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this._outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this._outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this._outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this._outputStream.length) {\n        let text = asOrNull(this._outputStream[i], StringValue);\n        if (text) {\n          this._outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this._outputStream.length - 1; i >= 0; i--) {\n      let c = this._outputStream[i];\n      if (c instanceof Glue) {\n        this._outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this._outputStream.length > 0) {\n      for (let i = this._outputStream.length - 1; i >= 0; i--) {\n        let obj = this._outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this._outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let i = 0; i < this._outputStream.length; i++) {\n      if (this._outputStream[i] instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this._outputStream.length - 1; i >= 0; i--) {\n      // var cmd = this._outputStream[i] as ControlCommand;\n      let cmd = asOrNull(this._outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint = this.callStack.currentElement\n      .functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this._outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this._outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this._outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      funcContainer\n    );\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[]) {\n    // Pass arguments onto the evaluation stack\n    if (args != null) {\n      for (let i = 0; i < args.length; i++) {\n        if (!(typeof args[i] === \"number\" || typeof args[i] === \"string\")) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string\"\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new StoryException(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight = this.callStack.currentElement\n      .evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStream: InkObject[];\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n  private _currentChoices: Choice[];\n\n  private _patch: StatePatch | null = null;\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 19;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions = JsonSerialisation.JTokenToListDefinitions(\n          listDefsObj\n        );\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.ToString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new StoryException(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = true;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = false;\n\n      this._asyncContinueActive = false;\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (change == Story.OutputStateChange.ExtendedBeyondNewline) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching();\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching();\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl = this.PerformLogicAndFlowControl(\n      currentContentObj\n    );\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0];\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      // var choiceOnlyStrVal = state.PopEvaluationStack () as StringValue;\n      let choiceOnlyStrVal = asOrThrows(\n        this.state.PopEvaluationStack(),\n        StringValue\n      );\n      choiceOnlyText = choiceOnlyStrVal.value || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      // var startStrVal = state.PopEvaluationStack () as StringValue;\n      let startStrVal = asOrThrows(\n        this.state.PopEvaluationStack(),\n        StringValue\n      );\n      startText = startStrVal.value || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents = this.state.variablesState.GetVariableWithName(\n          varName\n        );\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EndString:\n          let contentStackForString: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container = this.state.callStack.currentElement.currentPointer\n          .container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push.apply(outputStreamBefore, this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let func = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof func !== \"undefined\";\n\n    // Try to use fallback function?\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = func!(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, func);\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(funcName: string, func: Story.ExternalFunction) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(funcName, (args: any) => {\n      this.Assert(\n        args.length >= func.length,\n        \"External function expected \" + func.length + \" arguments\"\n      );\n\n      let coercedArgs = [];\n      for (let i = 0, l = args.length; i < l; i++) {\n        coercedArgs[i] = this.TryCoerce(args[i]);\n      }\n      return func.apply(null, coercedArgs);\n    });\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound = this.mainContentContainer.namedContent.has(\n              name\n            );\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new StoryException(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer: Story.VariableObserver,\n    specificVariableName: string\n  ) {\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (typeof specificVariableName !== \"undefined\") {\n      if (this._variableObservers.has(specificVariableName)) {\n        let observers = this._variableObservers.get(specificVariableName)!;\n\n        if (observer !== null) {\n          observers.splice(observers.indexOf(observer), 1);\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer !== null) {\n      let keys = this._variableObservers.keys();\n\n      for (let varName of keys) {\n        let observers = this._variableObservers.get(varName)!;\n        observers.splice(observers.indexOf(observer), 1);\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let tag = asOrNull(c, Tag);\n      if (tag) {\n        if (tags == null) tags = [];\n        tags.push(tag.text);\n      } else break;\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunction>;\n  private _variableObservers: Map<\n    string,\n    Story.VariableObserver[]\n  > | null = null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n"],"names":["Path","[object Object]","this","_components","_componentsString","_isRelative","arguments","componentsString","Component","head","tail","push","concat","Array","relative","isRelative","componentCount","length","tailComps","slice","self","lastComponent","lastComponentIdx","containsNamedComponent","i","l","isIndex","path","index","pathToAppend","p","upwardMoves","isParent","join","value","substring","componentStrings","split","str","test","parseInt","otherPath","Equals","c","apply","Debug","ValueType","PushPopType","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","indexOrName","parentId","toString","otherComp","Assert","condition","message","console","warn","trace","variable","NullException","throwNullException","InkObject","debugMetadata","_debugMetadata","parent","ownDebugMetadata","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","_path","comps","child","container","Container","namedChild","unshift","content","indexOf","nearestContainer","GetComponent","contentContainer","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","newPathComps","up","ToParent","down","globalPathStr","relativePathStr","PathByAppendingPath","ConvertPathToRelative","ancestor","prop","StringBuilder","string","Length","Append","format","args","replace","match","num","InkListItem","originName","itemName","nameParts","Null","isNull","fullName","otherItem","JSON","stringify","key","parse","isLikeInkListItem","inkListItem","item","hasOwnProperty","InkList","Map","super","otherList","_originNames","singleOriginListName","originStory","SetInitialOriginName","def","listDefinitions","TryListGetDefinition","exists","origins","result","singleElement","Add","Key","Value","itemOrItemName","AddItem","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","itemVal","ValueForItem","fromSerializedKey","has","serialized","serializedKey","set","delete","Count","size","originOfMaxItem","maxOriginName","maxItem","every","originNames","initialOriginName","initialOriginNames","max","minItem","inverse","list","items","ContainsKey","all","union","intersection","listToRemove","minBound","maxBound","ordered","orderedItems","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","SetInitialOriginNames","otherInkList","sort","x","y","localeCompare","sb","NaN","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","get","AbstractValue","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","StringValue","String","DivertTargetValue","ListValue","Create","targetType","valueObject","valueType","isTruthy","newType","BadCastException","_isNewline","_isInlineWhitespace","isNewline","isInlineWhitespace","isNonWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","targetPath","DivertTarget","VariablePointerValue","variableName","contextIndex","_contextIndex","VariablePointer","List","listOrSingleItem","singleValue","oldValue","newValue","oldList","newList","SearchResult","correctObj","approximate","searchResult","_content","AddContent","namedOnlyContent","namedOnlyContentDict","namedContent","inkObject","named","existingNamedOnly","AddToNamedContentOnly","countFlags","flags","visitsShouldBeCounted","CountFlags","Visits","turnIndexShouldBeCounted","Turns","countingAtStartOnly","CountStartOnly","flag","pathToFirstLeafContent","_pathToFirstLeafContent","internalPathToFirstLeafContent","components","contentObjOrList","contentList","contentObj","TryAddNamedContent","namedContentObj","AssertType","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","otherContainer","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","AppendFormat","AppendLine","onlyNamed","Glue","ControlCommand","commandType","CommandType","NotSet","_commandType","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","Pointer","PathByAppendingComponent","Divert","stackPushType","pushesToStack","_targetPath","targetObj","targetPointer","Resolve","_targetPointer","ResolvePath","StartOf","copy","targetPathString","CompactPathString","hasVariableTarget","variableDivertName","otherDivert","targetStr","isConditional","Function","ChoicePoint","onceOnly","pathOnChoice","_pathOnChoice","choiceTargetObj","choiceTarget","pathStringOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","VariableReference","containerForCount","pathForCount","pathStringForCount","VariableAssignment","isNewDeclaration","isGlobal","Void","NativeFunctionCall","GenerateNativeFunctionsIfNecessary","numberOfParameters","_isPrototype","functionName","_nativeFunctions","_name","_prototype","_numberOfParameters","parameters","Call","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","_operationFuncs","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","listIntParams","listVal","resultInkList","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","inkObjectVal","castedValue","Cast","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","GreaterThanOrEquals","LessThanOrEquals","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","Union","Without","Contains","Intersect","GreaterThan","LessThan","AddListUnaryOp","Invert","All","ListMin","MinAsList","ListMax","MaxAsList","ValueOfList","divertTargetsEqual","d1","d2","divertTargetsNotEqual","AddOpToNativeFunc","nativeFunc","AddOpFuncForType","Tag","tagText","text","Choice","ListDefinition","_items","_itemNameToValues","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listValue","listOfLists","definition","JsonSerialisation","jArray","skipLast","count","jTok","runtimeObj","JTokenToRuntimeObject","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteArrayStart","WriteArrayEnd","dict","WriteIntProperty","WriteRuntimeContainer","divert","divTypeKey","isExternal","Tunnel","WriteProperty","externalArgs","choicePoint","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","varRef","readCountPath","varAss","tag","choice","WriteChoice","jObject","token","firstChar","CallExistsWithName","CallWithName","isArray","propValue","varPtr","isDivert","divPushType","external","target","readCountVarRef","isVarAss","isGlobalVar","varName","isNewDecl","undefined","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","withoutName","hasNameProperty","hasTerminator","namedContainer","WriteNull","JArrayToRuntimeObjList","terminatingObj","namedContentItem","namedSubContainer","jObj","sourcePath","originalThreadIndex","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","listDefJson","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","Story","storyContext","_startOfRoot","Reset","toCopy","_threads","otherThread","Copy","_threadCounter","elements","callStack","depth","currentElement","cs","callstack","currentElementIndex","currentThread","canPop","Thread","Element","jThreads","jThreadTok","jThreadObj","thread","w","WriteObject","WriteJson","newThread","threadIndex","forkedThread","canPopThread","splice","elementIsEvaluateFromGame","FunctionEvaluationFromGame","externalEvaluationStackHeight","outputStreamLengthWithPushed","element","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","CanPop","pop","varValue","temporaryVariables","declareNew","contextElement","RetainListOriginsForAssignment","filtered","filter","callStackTrace","isCurrent","pointer","inExpressionEvaluation","jThreadCallstack","jElTok","currentContainerPathStr","jElementObj","pushPopType","currentContainerPathStrToken","threadPointerResult","Warning","el","temps","JObjectToDictionaryRuntimeObjs","clear","prevContentObjPath","prevPath","previousPointer","PointerAtPath","e","WriteDictionaryRuntimeObjs","resolvedPointer","VariablesState","listDefsOrigin","Set","_globalVariables","_callStack","_listDefsOrigin","Proxy","$","callback","variableChangedEventCallbacks","batchObservingVariableChanges","_batchObservingVariableChanges","_changedVariablesForBatchObs","currentValue","variableChangedEvent","varContents","patch","TryGetGlobal","_defaultGlobalVariables","SetGlobal","namedVarKey","namedVarValue","globals","changedVariables","add","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","constructor","GetRawVariableWithName","varPointer","ValueAtVariablePointer","variableValue","FindSingleItemListWithName","GetTemporaryVariableWithName","GetVariableWithName","setGlobal","GlobalVariableExistsWithName","ResolveVariablePointer","existingPointer","SetTemporaryVariable","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","PRNG","seed","next","StatePatch","_globals","_changedVariables","_visitCounts","_turnIndices","visitCounts","turnIndices","SimpleJson","Reader","ToDictionary","ToArray","_rootObject","Writer","inner","StartNewObject","newObject","state","State","Property","currentCollection","currentPropertyName","propertyName","_propertyNameStack","_collectionStack","None","_jsonObject","_stateStack","StateElement","Object","innerOrContent","IncrementChildCount","childCount","_currentPropertyName","PropertyName","escape","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","_currentString","currEl","StoryState","story","_outputStream","OutputStreamDirty","_evaluationStack","_variablesState","currentTurnIndex","timeSeed","Date","getTime","storySeed","previousRandom","_currentChoices","GoToStart","indented","ToString","ToJson","json","TextToDictionary","LoadJsonObj","pathString","visitCountOut","_patch","TryGetVisitCount","containerPathStr","count2","currCount","VisitCountForContainer","SetVisitCount","SetTurnIndex","TryGetTurnIndex","index2","callstackDepth","outputStream","currentChoices","canContinue","generatedChoices","currentErrors","_currentErrors","currentWarnings","_currentWarnings","variablesState","evaluationStack","_currentTurnIndex","currentPathString","hasError","hasWarning","currentText","_outputStreamTextDirty","outputObj","textContent","_currentText","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","currentTags","_outputStreamTagsDirty","_currentTags","mainContentContainer","divertedPointer","didSafeExit","ApplyPatch","ApplyCountChanges","newCount","isVisit","hasChoiceThreads","threadAtGeneration","ThreadWithIndex","WriteListRuntimeObjs","WriteIntDictionary","kInkSaveStateVersion","inkVersionCurrent","jSaveVersion","kMinCompatibleLoadVersion","SetJsonToken","currentDivertTargetPath","divertPath","JObjectToIntDictionary","jChoiceThreads","foundActiveThread","jSavedChoiceThread","objs","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","glue","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","trimIndex","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","cmd","txt","inStringEvaluation","n","numberOfObjects","functionStartPoint","popType","TrimWhitespaceFromFunctionEnd","Pop","incrementingTurnIndex","newPointer","funcContainer","Push","PassArgumentsToEvaluationStack","PushEvaluationStack","originalEvaluationStackHeight","returnedObj","poppedObj","PopEvaluationStack","PopCallStack","returnVal","isWarning","Stopwatch","startTime","ElapsedMilliseconds","nVal","isFinite","_mainContentContainer","jsonString","_listDefinitions","_externals","rootObject","versionObj","formatFromFile","inkVersionMinimumCompatible","listDefsObj","rootToken","JTokenToListDefinitions","ResetState","choices","_state","IfAsyncWeCant","shouldReturn","ObserveVariableChange","VariableStateDidChangeEvent","bind","ResetGlobals","ResetErrors","ForceEnd","originalPointer","ChoosePath","ContinueInternal","SnapshotDefaultGlobals","ContinueAsync","asyncContinueComplete","_asyncContinueActive","millisecsLimitAsync","_hasValidatedExternals","ValidateExternalBindings","_profiler","PreContinue","isAsyncTimeLimited","_recursiveContinueCount","ResetOutput","durationStopwatch","Start","ContinueSingleStep","AddError","Stop","_stateSnapshotAtLastNewline","RestoreStateSnapshot","_temporaryEvaluationContainer","PostContinue","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","change","CalculateNewlineOutputStateChange","OutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","Continue","pathLengthToUse","CopyAndStartPatching","RestoreAfterPatch","_asyncSaving","ApplyAnyPatch","stateToSave","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","ContextForVariableNamed","PushToOutputStream","NextContent","PushThread","atStart","IncrementVisitCountForContainer","RecordTurnIndexVisitToContainer","_prevContainers","prevAncestor","currentChildOfContainer","currentContainerAncestor","enteringAtStart","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","ForkThread","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","sourceName","evalCommand","output","PeekEvaluationStack","overrideTunnelReturnTarget","popped","TryExitFunctionEvaluationFromGame","names","expected","errorMsg","contentStackForString","outputCountConsumed","command","PopFromOutputStream","reverse","choiceCount","extraNote","eitherCount","divertTarget","TurnsSinceForContainer","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","PopThread","listNameVal","generatedListValue","foundItem","targetList","ListWithSubRange","listItemIndex","listEnumerator","entries","randomItem","assignedVal","Assign","foundValue","func","funcParams","resetCallstack","ResetCallstack","funcDetail","activityStr","SetChosenPath","VisitChangedContainersDueToDivert","choiceIdx","choiceToChoose","KnotContainerWithName","returnTextOutput","trim","outputStreamBefore","StartFunctionEvaluationFromGame","stringOutput","textOutput","CompleteFunctionEvaluationFromGame","returned","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","fallbackFunctionContainer","allowExternalFunctionFallbacks","valueObj","funcResult","returnObj","BindExternalFunctionGeneral","coercedArgs","TryCoerce","missingExternals","from","innerContent","observer","_variableObservers","variableNames","observers","ObserveVariable","specificVariableName","keys","newValueObj","globalTags","TagsAtStartOfFlowContainerWithPathString","flowContainer","firstContent","tags","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","allChoices","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","charCodeAt","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","endLineNumber","fileName"],"mappings":"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"}